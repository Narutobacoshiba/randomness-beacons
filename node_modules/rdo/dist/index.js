"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const english_chars_1 = __importDefault(require("english-chars"));
const md5_1 = __importDefault(require("md5"));
const cross_blob_util_1 = require("cross-blob-util");
const request_1 = require("./request");
const is_uuid_1 = __importDefault(require("is-uuid"));
/**
 * Random.org API client library for JavaScript.
*/
class Rdo {
    constructor(conf = {}) {
        this.conf = conf;
        /**
         * If authenticated via an API key.
        */
        this.isAuthed = false;
        /**
         * If authenticated via credentials.
        */
        this.hasCreds = false;
        /**
         * The Third-Party Draw Service allows clients to hold ‘drawings’ (US English) or ‘draws’ (UK, Irish and Australian English) in which a number of winners are selected from a pool of entries.
        */
        this.draw = {
            /**
             * Hold a drawing in one single operation. All information required for the drawing is passed as parameters. For this reason, the client must have collected all the entries from which the winner(s) will be selected before the method is invoked. Once the invocation is made, it is not possible to add entries or to delete or modify the drawing.
            */
            hold: async function hold({ title, recordType = "public", entries, winnerCount = 1, entryType = "opaque", identicalEntriesPermitted = false, winnerStart = 1, winnerHandling = "remove", showEntries = true, showWinners = true, delegationKey = null, }) {
                this.mustHaveCreds();
                const { drawId, status, entryCount, winners, completionTime, recordUrl } = await request_1.reqAPI("holdDraw", {
                    data: {
                        credentials: this.conf.credentials,
                        title,
                        recordType,
                        entries,
                        entriesDigest: md5_1.default(JSON.stringify(entries)),
                        winnerCount,
                        entryType,
                        identicalEntriesPermitted,
                        winnerStart,
                        winnerHandling,
                        showEntries,
                        showWinners,
                        delegationKey
                    },
                    getRandomData: false
                });
                if (entryCount !== entries.length)
                    throw new ReferenceError("Processed entries do not equal provided entries!");
                return {
                    drawID: drawId,
                    status,
                    entryCount,
                    winners,
                    completionTime: new Date(completionTime),
                    recordURL: recordUrl
                };
            },
            /**
             * Obtain information about a completed drawing, subject to access control of the drawing's privacy settings.
            */
            get: async function get({ drawID, maxEntries = 3000000, delegationKey = null, }) {
                const { drawId, title, recordType, entryType, winnerStart, winnerHandling, showEntries, showWinners, status, ownerId, ownerName, ownerTimeZone, drawNumber, entryCount, entries, winnerCount, winners, completionTime, recordUrl } = await request_1.reqAPI("getDraw", {
                    data: {
                        drawId: drawID,
                        maxEntries,
                        credentials: this.hasCreds ? this.conf.credentials : null,
                        delegationKey,
                    },
                    getRandomData: false
                });
                return {
                    drawID: drawId,
                    title,
                    recordType,
                    entryType,
                    winnerStart,
                    winnerHandling,
                    showEntries,
                    showWinners,
                    status,
                    ownerID: ownerId,
                    ownerName,
                    ownerTimeZone,
                    drawNumber,
                    entryCount,
                    entries,
                    winnerCount,
                    winners,
                    completionTime: new Date(completionTime),
                    recordURL: recordUrl
                };
            },
            /**
             * This method lets a RANDOM.ORG account holder list all the drawings in their account. Your client must set the method property of its JSON-RPC request object to listDraws.
            */
            list: async function list({ delegationKey = null, } = {}) {
                this.mustHaveCreds();
                const res = await request_1.reqAPI("listDraws", {
                    data: {
                        credentials: this.conf.credentials,
                        delegationKey
                    },
                    getRandomData: false
                });
                return res.map(({ drawId, title, recordType, entryType, winnerStart, winnerHandling, showEntries, showWinners, status, ownerId, ownerName, ownerTimeZone, drawNumber, entryCount, entries, winnerCount, winners, completionTime, recordUrl }) => ({
                    drawID: drawId,
                    title,
                    recordType,
                    entryType,
                    winnerStart,
                    winnerHandling,
                    showEntries,
                    showWinners,
                    status,
                    ownerID: ownerId,
                    ownerName,
                    ownerTimeZone,
                    drawNumber,
                    entryCount,
                    entries,
                    winnerCount,
                    winners,
                    completionTime: new Date(completionTime),
                    recordURL: recordUrl
                }));
            },
        };
        /**
         * This API gives clients access to RANDOM.ORG's Multi-Round Giveaway Service. Ideally suited to video streaming in real-time, the service randomizes your list of up to 3,000 participants in up to 30 rounds. The client first creates the giveaway and then runs the rounds one at a time. In the final round, the service generates a verification code, valid for one month, which proves your giveaway wasn't rigged.
        */
        this.giveaway = {
            /**
             * This method creates a new giveaway but does not yet run the rounds.
            */
            begin: async function begin({ description, entries, rounds, delegationKey = null, }) {
                this.mustHaveCreds();
                const { giveawayKey, ownerId, roundsHeld, created, completed, expires, completionTime } = await request_1.reqAPI("beginGiveaway", {
                    data: {
                        credentials: this.conf.credentials,
                        description,
                        entries,
                        entriesDigest: md5_1.default(JSON.stringify(entries)),
                        rounds,
                        delegationKey
                    },
                    getRandomData: false
                });
                return {
                    giveawayKey,
                    ownerID: ownerId,
                    description,
                    entries,
                    rounds,
                    roundsHeld,
                    created: new Date(created),
                    completed: new Date(completed),
                    expires: new Date(expires),
                    completionTime: new Date(completionTime)
                };
            },
            /**
             * This method runs a single round of a giveaway previously created with the begin method.
            */
            cont: async function cont({ giveawayKey, delegationKey = null, }) {
                this.mustHaveCreds();
                const { ownerId, description, entries, rounds, roundsHeld, created, completed, expires, completionTime } = await request_1.reqAPI("continueGiveaway", {
                    data: {
                        credentials: this.conf.credentials,
                        giveawayKey,
                        delegationKey
                    },
                    getRandomData: false
                });
                return {
                    giveawayKey,
                    ownerID: ownerId,
                    description,
                    entries,
                    rounds,
                    roundsHeld,
                    created: new Date(created),
                    completed: new Date(completed),
                    expires: new Date(expires),
                    completionTime: new Date(completionTime)
                };
            },
            /**
             * This method obtains the details of a giveaway. The giveaway must have been created with the being method and can be either in completed or not completed state. The records of giveaways are public, so no authentication is required to use this method.
            */
            get: async function get({ giveawayKey, }) {
                const { ownerId, description, entries, rounds, roundsHeld, created, completed, expires } = await request_1.reqAPI("getGiveaway", {
                    data: {
                        giveawayKey,
                    },
                    getRandomData: false
                });
                return {
                    giveawayKey,
                    ownerID: ownerId,
                    description,
                    entries,
                    rounds,
                    roundsHeld,
                    created: new Date(created),
                    completed: new Date(completed),
                    expires: new Date(expires),
                };
            },
            /**
             * This method lists all non-expired giveaways for a given RANDOM.ORG account.
            */
            list: async function list({ delegationKey = null, } = {}) {
                this.mustHaveCreds();
                const res = await request_1.reqAPI("getGiveaway", {
                    data: {
                        credentials: this.conf.credentials,
                        delegationKey,
                    },
                    getRandomData: false
                });
                return res.map(({ giveawayKey, ownerId, description, entries, rounds, roundsHeld, created, completed, expires }) => ({
                    giveawayKey,
                    ownerID: ownerId,
                    description,
                    entries,
                    rounds,
                    roundsHeld,
                    created: new Date(created),
                    completed: new Date(completed),
                    expires: new Date(expires),
                }));
            }
        };
        /**
         * The methods described here allows RANDOM.ORG account holders to delegate use of services to other RANDOM.ORG account holders.
         * A ‘delegation’ is a relationship between two RANDOM.ORG accounts in which one (the delegator) gives another (the delegate) access to use a particular service (e.g., the Third-Party Draw Service) on behalf of the delegator. The delegator can later remove the delegation if it wishes.
        */
        this.delegation = {
            /**
             * Create a delegation of a particular service between two RANDOM.ORG account holders.
            */
            async add({ serviceID, delegateID, notifyDelegate = true, }) {
                this.mustHaveCreds();
                return await this.reqAPI("addDelegation", {
                    data: {
                        credentials: this.conf.credentials,
                        serviceId: serviceID,
                        delegateId: delegateID,
                        notifyDelegate,
                    },
                    getRandomData: false
                });
            },
            /**
             * Allow a delegator to remove a delegation, effectively revoking rights previously granted with the add method.
            */
            async remove({ delegationKey, notifyDelegate = true, }) {
                this.mustHaveCreds();
                const res = await this.reqAPI("removeDelegation", {
                    data: {
                        credentials: this.conf.credentials,
                        delegationKey,
                        notifyDelegate,
                    },
                    getRandomData: false
                });
                return res === {};
            },
            /**
             * List all delegations in which the user acts as delegator or delegate.
            */
            async list() {
                this.mustHaveCreds();
                const { delegations } = await request_1.reqAPI("listDelegations", {
                    data: {
                        credentials: this.conf.credentials
                    },
                    getRandomData: false
                });
                return delegations.map(delegations, ({ serviceId, delegatorId, delegateId, delegationKey }) => ({
                    serviceID: serviceId,
                    delegatorID: delegatorId,
                    delegateID: delegateId,
                    delegationKey
                }));
            },
            /**
             * Register a handler that will be used to deliver notifications about the creation and deletion of delegations in which the account holder is delegate.
            */
            handler: {
                /**
                 * Register a handler that will be used to deliver notifications about the creation and deletion of delegations in which the account holder is delegate.
                */
                async set({ handlerURL, handlerSecret, }) {
                    this.mustHaveCreds();
                    const res = await request_1.reqAPI("setNotificationHandler", {
                        data: {
                            credentials: this.conf.credentials,
                            handlerUrl: handlerURL,
                            handlerSecret,
                        },
                        getRandomData: false
                    });
                    return res === {};
                },
                /**
                 * Remove the handler that is being used to deliver notifications about the creation and deletion of delegations in which the account holder is delegate.
                */
                async remove() {
                    this.mustHaveCreds();
                    const res = await request_1.reqAPI("setNotificationHandler", {
                        data: {
                            credentials: this.conf.credentials,
                            handlerUrl: null,
                            handlerSecret: null,
                        },
                        getRandomData: false
                    });
                    return res === {};
                },
            }
        };
        if (this.conf) {
            if (this.conf.apiKey) {
                if (is_uuid_1.default.v4(this.conf.apiKey))
                    this.isAuthed = true;
                else
                    throw new TypeError("API Key must be a valid v4 UUID.");
            }
            if (this.conf.credentials) {
                this.hasCreds = (this.conf.credentials.login && this.conf.credentials.password) || this.conf.credentials.sessionId;
            }
        }
    }
    /**
     * Throw an error if not authenticated via an API key.
    */
    mustBeAuthed() {
        if (!this.isAuthed)
            throw new ReferenceError("An API key is required to use this function!");
    }
    /**
     * Throw an error if not authenticated via some credentials.
    */
    mustHaveCreds() {
        if (!this.hasCreds)
            throw new ReferenceError("Credentials must be provided to use this function!");
    }
    /**
     * Generate true random integers within a user-defined range.
    */
    async integer({ min, max, amount = 1, unique = false, base = 10, }) {
        if (this.isAuthed) {
            return await request_1.reqAPI("generateIntegers", {
                data: {
                    apiKey: this.conf.apiKey,
                    n: amount,
                    min,
                    max,
                    replacement: !unique,
                    base,
                },
                signed: this.conf.signed
            });
        }
        else {
            return await request_1.reqPublic("integers", {
                data: {
                    num: amount,
                    min,
                    max,
                    col: 1,
                    base,
                },
                convertToNumber: true
            });
        }
    }
    /**
     * Generate true random [decimal fractions](http://en.wikipedia.org/wiki/Decimal#Decimal_fractions) from a uniform distribution across the [0,1] interval with a user-defined number of [decimal places](http://en.wikipedia.org/wiki/Arithmetic_precision).
    */
    async decimal({ amount = 1, places = 14, unique = false, } = {}) {
        this.mustBeAuthed();
        return await request_1.reqAPI("generateDecimalFractions", {
            data: {
                apiKey: this.conf.apiKey,
                n: amount,
                decimalPlaces: places,
                replacement: !unique
            },
            signed: this.conf.signed
        });
    }
    /**
     * Generate uniform or multiform sequences of true random integers within user-defined ranges. Uniform sequences all have the same general form (length, range, replacement and base) whereas these characteristics can vary for multiform sequences.
    */
    async sequence({ min, max, amount = 1, length = 1, unique = false, base = 10, }) {
        this.mustBeAuthed();
        return await request_1.reqAPI("generateIntegerSequences", {
            data: {
                apiKey: this.conf.apiKey,
                n: amount,
                length,
                min,
                max,
                replacement: !unique,
                base
            },
            signed: this.conf.signed
        });
    }
    /**
     * Generate true random numbers from a [Gaussian distribution](http://en.wikipedia.org/wiki/Normal_distribution) (also known as a normal distribution). The form uses a [Box-Muller Transform](http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform) to generate the Gaussian distribution from uniformly distributed numbers.
    */
    async gaussian({ amount = 1, mean, standardDeviation, significantDigits, }) {
        this.mustBeAuthed();
        return await request_1.reqAPI("generateGaussians", {
            data: {
                apiKey: this.conf.apiKey,
                n: amount,
                mean,
                standardDeviation,
                significantDigits
            },
            signed: this.conf.signed
        });
    }
    /**
     * This method generates true random strings.
    */
    async string({ amount = 1, length = 1, characters = english_chars_1.default.all, unique = false, } = {}) {
        if (Array.isArray(characters))
            characters = characters.join("");
        if (this.isAuthed) {
            return await request_1.reqAPI("generateStrings", {
                data: {
                    apiKey: this.conf.apiKey,
                    n: amount,
                    length,
                    characters,
                    replacement: !unique
                },
                signed: this.conf.signed
            });
        }
        else {
            return await request_1.reqPublic("strings", {
                data: {
                    num: amount,
                    len: length,
                    digits: characters.includes(english_chars_1.default.digits) ? "on" : "off",
                    upperalpha: characters.includes(english_chars_1.default.uppercase) ? "on" : "off",
                    loweralpha: characters.includes(english_chars_1.default.lowercase) ? "on" : "off",
                    unique: unique ? "on" : "off",
                }
            });
        }
    }
    /**
     * Generate version 4 true random [Universally Unique IDentifiers](http://en.wikipedia.org/wiki/Universally_unique_identifier) (UUIDs) in accordance with section 4.4 of [RFC 4122](http://www.ietf.org/rfc/rfc4122.txt).
    */
    async uuid({ amount = 1, } = {}) {
        this.mustBeAuthed();
        return await request_1.reqAPI("generateUUIDs", {
            data: {
                apiKey: this.conf.apiKey,
                n: amount
            },
            signed: this.conf.signed
        });
    }
    /**
     * Generates [Binary Large OBjects](http://en.wikipedia.org/wiki/Binary_large_object) (BLOBs) containing true random data.
    */
    async blob({ amount = 1, size = 8, } = {}) {
        this.mustBeAuthed();
        const data = await request_1.reqAPI("generateBlobs", {
            data: {
                apiKey: this.conf.apiKey,
                n: amount,
                size,
                format: "base64"
            },
            signed: this.conf.signed
        });
        return data.map((val) => cross_blob_util_1.base64StringToBlob(val));
    }
    async quota() {
        if (this.isAuthed) {
            const { status, creationTime, bitsLeft, requestsLeft, totalBits, totalRequests } = await request_1.reqAPI("getUsage", {
                data: {
                    apiKey: this.conf.apiKey
                },
                getRandomData: false
            });
            return {
                running: status === "running",
                creationTime: new Date(creationTime),
                bitsLeft,
                requestsLeft,
                totalBits,
                totalRequests
            };
        }
        else {
            const res = await request_1.reqPublic("quota", {
                convertToNumber: true
            });
            return res[0];
        }
    }
}
exports.default = Rdo;
module.exports = Rdo;
//# sourceMappingURL=index.js.map